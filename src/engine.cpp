#include "engine.h"
#include "util.h"
#include <regex>
#include <vector>

std::string A::b(const std::string& a) {
    std::string b = u::p(a);
    if (b.empty()) return this->a.b();
    std::string c = b;
    if (u::c(c, "bye") || u::c(c, "退出") || u::c(c, "再见")) return "再见";
    if (u::c(c, "时间") || u::c(c, "几点")) return std::string("现在是 ") + u::n();
    if (u::c(c, "名字") || u::c(c, "你是谁")) return "我还没有名字，你可以叫我小A";

    struct C { std::regex a; std::vector<std::string> b; };
    static std::vector<C> d = {
        {std::regex("^\\s*(你好|嗨|在吗|hello).*$"), {"我在，今天过得怎么样", "你好，我们可以聊聊你在想什么", "嗨，你想从哪里开始"}},
        {std::regex("^\\s*是(的)?\\s*$"), {"为什么这么确定", "具体原因是什么", "这让你想到什么"}},
        {std::regex("^\\s*不(是)?\\s*$"), {"哪里不对", "是什么让你这么说不是", "如果是另一种情况你会怎么想"}},
        {std::regex("我觉得(.+)"), {"为什么你觉得$1", "是什么让你觉得$1", "$1 让你有什么感觉"}},
        {std::regex("我想要?(.+)"), {"是什么让你想要$1", "如果得到$1，你会怎样", "阻碍你$1的是啥"}},
        {std::regex("我不想(.+)"), {"为什么不想$1", "不想$1会带来什么", "如果必须$1，你会怎么做"}},
        {std::regex("我不能(.+)"), {"是什么阻止你$1", "如果可以$1，会发生什么", "你觉得第一步是什么"}},
        {std::regex("因为(.+)"), {"除了$1 还有别的原因吗", "$1 是唯一的原因吗", "如果不是$1 你会怎么解释"}},
        {std::regex("你能(.+)吗"), {"你希望我$1吗", "如果我能$1 对你意味着什么", "你更希望我怎么做"}},
        {std::regex("可以(.+)吗"), {"你希望能$1吗", "如果可以$1 你会先做什么", "是什么阻碍你$1"}},
        {std::regex("我(很|好|太)?(开心|高兴|快乐)"), {"$2从什么时候开始的", "$2时你会做什么", "谁和什么会让你$2"}},
        {std::regex("我(很|太)?(难过|伤心|沮丧|抑郁)"), {"$2时最影响你的是什么", "有人支持你吗", "有什么能让你稍微好一点"}},
        {std::regex("我(很|太)?(生气|愤怒)"), {"是什么触发了$2", "如果不去反应你会怎样", "你希望别人怎么做"}},
        {std::regex("我(很|太)?(焦虑|紧张|压力)"), {"它最明显的场景是什么", "你怎么缓解它", "是什么加剧了它"}},
        {std::regex("我(很|太)?(害怕|恐惧)"), {"你在担心什么", "最坏的情况是什么", "如果发生了你会怎么面对"}},
        {std::regex("(期待|希望)"), {"你最期待什么", "为了它你能做的小一步是什么", "如果实现了会怎样"}},
        {std::regex("(工作|上班|加班)"), {"关于工作最困扰你的是什么", "你想改善哪一块", "理想的状态是什么"}},
        {std::regex("(学习|考试|作业)"), {"学习里最难的是什么", "你如何安排时间", "你擅长的方式是什么"}},
        {std::regex("(家庭|父母|孩子|伴侣|恋人|朋友|同事|关系)"), {"你和他们相处时最在意什么", "这段关系理想的样子是什么", "最近发生了什么"}},
        {std::regex("(健康|睡眠|失眠|饮食|运动|锻炼)"), {"这对你的影响是什么", "你愿意尝试什么改变", "从哪件小事开始"}},
        {std::regex("(钱|收入|工资|消费|花费|存款|债务)"), {"金钱对你意味着什么", "你更看重安全感还是自由", "短期内你能做什么调整"}},
        {std::regex("(计划|目标|安排|打算)"), {"你打算如何开始第一步", "什么会是阻碍", "你如何知道自己在前进"}},
        {std::regex("为什么(.+)"), {"如果不是$1 你认为会是什么原因", "你认为背后真正的动机是什么", "对你最重要的部分是什么"}},
        {std::regex("梦(到)?(.+)"), {"这个梦让你有什么感受", "你觉得梦里的$2象征着什么", "这个梦和现实有什么联系"}},
        {std::regex("(谢谢|多谢|感恩)"), {"不客气，还有什么想聊的", "彼此彼此", "很高兴能帮到你"}},
        {std::regex("(对不起|抱歉)"), {"是什么让你这么说", "你希望怎样补救", "你在担心什么后果"}},
        {std::regex("(孤独|寂寞|空虚)"), {"什么时候最明显", "谁能让你感觉好一些", "你会如何照顾自己"}},
        {std::regex("(无聊|没意思)"), {"当你无聊时通常会做什么", "什么事情能让你觉得有意义", "你想尝试什么新的事"}},
        {std::regex("喜欢(.+)"), {"你为什么喜欢$1", "喜欢$1给你带来什么", "你如何表达这种喜欢"}},
        {std::regex("讨厌(.+)"), {"$1哪一部分最让你不舒服", "如果无法避免$1 你会如何相处", "是什么让你形成了这种感觉"}},
        {std::regex("(困惑|迷茫)"), {"最困惑的点是什么", "你有哪些可选方向", "你会如何做一个小实验"}},
        {std::regex("(后悔)"), {"你最想弥补什么", "从中你学到了什么", "如果再来一次你会怎么选"}},
        {std::regex("(害羞|自卑)"), {"这种感觉来自哪里", "如果自信一点你会做什么", "有没有谁能支持你"}},
        {std::regex("(成功|失败)"), {"你如何定义它", "最近一次让你有这种感觉的事是什么", "你会如何复盘"}},
        {std::regex("(天气|新闻)"), {"我不连网，但可以聊聊你对它的看法", "你对最近的事情怎么看", "它让你有什么感受"}}
    };

    for (auto& e : d) {
        std::smatch f;
        if (std::regex_search(c, f, e.a)) {
            int g = u::r(0, (int)e.b.size() - 1);
            std::string h = std::regex_replace(c, e.a, e.b[g]);
            return u::x(h);
        }
    }

    if (u::c(c, "？") || u::c(c, "?")) return this->a.c(c);

    static std::vector<std::string> e = {
        "听起来这对你很重要", "如果放慢一点你会怎么做", "你觉得自己忽略了什么",
        "说说你最在意的那个细节", "有没有一个你能立刻做的改变",
        "当下你最需要什么", "你希望别人怎么理解你"
    };
    if ((int)c.size() < 18) {
        int f = u::r(0, (int)e.size() - 1);
        return u::x(std::string("为什么 ") + c + "，" + e[f]);
    }
    int f = u::r(0, 2);
    if (f == 0) return this->a.d(c);
    int g = u::r(0, (int)e.size() - 1);
    return u::x(c + "，" + e[g]);
}
